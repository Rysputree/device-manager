Phase 1: Manual Device Pairing (Trial/MVP)
Architecture Overview
Device 1 (has Owner account)     Device 2 (fresh/unconfigured)
192.168.1.10                     192.168.1.11
FastAPI App                      FastAPI App
├─ Owner: admin                  ├─ No users yet
├─ SQLite DB                     ├─ SQLite DB (empty)
└─ Pairing Token                 └─ Waiting for pairing
Step-by-Step Implementation
1. Device States
python# models/device.py
from enum import Enum

class DeviceState(str, Enum):
    UNCONFIGURED = "unconfigured"  # Fresh boot, no owner
    CONFIGURED = "configured"      # Has owner, not paired
    PAIRED = "paired"             # Paired with other devices
    STANDALONE = "standalone"     # Operating independently

class DeviceInfo(BaseModel):
    device_id: str
    serial_number: str
    name: str
    ip_address: str
    state: DeviceState
    is_manager: bool = False
    manager_device_id: Optional[str] = None
    paired_devices: List[str] = []
2. Initial Setup Flow
Device 1 (First Device):
python# After owner creates account in setup wizard
async def complete_setup(owner_data: OwnerCreate):
    # Create owner account
    user = await create_user(owner_data, role="owner")
    
    # Update device state
    await db.execute(
        "UPDATE device_metadata SET value = 'configured' WHERE key = 'device_state'"
    )
    
    # Generate pairing capability
    device_info = {
        "device_id": settings.device_id,
        "state": "configured",
        "can_pair": True,
        "is_manager": False  # Can become manager when pairing
    }
    
    return {"message": "Setup complete", "device": device_info}
Device 2 (Second Device):

Boots in unconfigured state
No setup required yet (will be configured during pairing)
Listening for pairing requests

3. Manual Device Discovery (IP-Based)
python# devices/routes.py

@router.post("/api/devices/discover/manual")
async def manual_device_discovery(
    ip_address: str,
    current_user: User = Depends(require_owner_or_admin)
):
    """Manually add a device by IP address for pairing"""
    
    try:
        # Try to connect to the device
        async with httpx.AsyncClient(verify=False, timeout=10.0) as client:
            response = await client.get(
                f"https://{ip_address}:8000/api/devices/info"
            )
            
            if response.status_code == 200:
                device_info = response.json()
                
                # Check if device is available for pairing
                if device_info["state"] in ["unconfigured", "configured"]:
                    return {
                        "discovered": True,
                        "device": device_info,
                        "can_pair": True
                    }
                else:
                    return {
                        "discovered": True,
                        "device": device_info,
                        "can_pair": False,
                        "reason": f"Device already in state: {device_info['state']}"
                    }
            else:
                raise HTTPException(400, "Device not responding correctly")
                
    except httpx.TimeoutException:
        raise HTTPException(408, f"Device at {ip_address} not reachable")
    except Exception as e:
        raise HTTPException(500, f"Discovery failed: {str(e)}")
4. Secure Pairing Mechanism
Generate Pairing Token (Device 1 initiates):
python# devices/pairing.py
import secrets
import hashlib
from datetime import datetime, timedelta

class PairingService:
    
    def generate_pairing_token(self, source_device_id: str, target_device_id: str) -> str:
        """Generate secure token for device pairing"""
        
        # Create unique pairing token
        token_data = f"{source_device_id}:{target_device_id}:{datetime.utcnow().isoformat()}"
        random_salt = secrets.token_urlsafe(32)
        
        pairing_token = hashlib.sha256(
            f"{token_data}:{random_salt}".encode()
        ).hexdigest()
        
        # Store in database with expiration
        await db.execute(
            """
            INSERT INTO pairing_tokens 
            (token, source_device_id, target_device_id, expires_at, used)
            VALUES (?, ?, ?, ?, ?)
            """,
            (pairing_token, source_device_id, target_device_id, 
             datetime.utcnow() + timedelta(minutes=10), False)
        )
        
        return pairing_token
Pairing Flow:
python# Step 1: Device 1 initiates pairing request
@router.post("/api/devices/pair/initiate")
async def initiate_pairing(
    target_ip: str,
    current_user: User = Depends(require_owner_or_admin)
):
    """Device 1 initiates pairing with Device 2"""
    
    # Get device info from target
    async with httpx.AsyncClient(verify=False) as client:
        response = await client.get(f"https://{target_ip}:8000/api/devices/info")
        target_info = response.json()
    
    # Generate pairing token
    pairing_token = await pairing_service.generate_pairing_token(
        settings.device_id,
        target_info["device_id"]
    )
    
    # Generate shared secret for future communication
    shared_secret = secrets.token_urlsafe(32)
    
    # Send pairing request to Device 2
    async with httpx.AsyncClient(verify=False) as client:
        response = await client.post(
            f"https://{target_ip}:8000/api/devices/pair/request",
            json={
                "source_device_id": settings.device_id,
                "source_ip": get_local_ip(),
                "source_name": settings.device_name,
                "pairing_token": pairing_token,
                "shared_secret": shared_secret,
                "initiated_by_user": current_user.username
            },
            timeout=30.0
        )
    
    if response.status_code == 200:
        # Store paired device info
        await db.execute(
            """
            INSERT INTO paired_devices 
            (device_id, ip_address, shared_secret, role, paired_at)
            VALUES (?, ?, ?, ?, ?)
            """,
            (target_info["device_id"], target_ip, shared_secret, 
             "sensor", datetime.utcnow())
        )
        
        # Mark this device as manager
        await db.execute(
            "UPDATE device_metadata SET value = 'true' WHERE key = 'is_manager'"
        )
        
        return {
            "status": "paired",
            "device": target_info,
            "relationship": "manager"
        }
    else:
        raise HTTPException(500, "Pairing request rejected")


# Step 2: Device 2 receives and accepts pairing
@router.post("/api/devices/pair/request")
async def accept_pairing_request(request: PairingRequest):
    """Device 2 accepts pairing request from Device 1"""
    
    # Validate pairing token (optional for trial, important for production)
    # For trial, we can skip complex validation
    
    # Store the source device as manager
    await db.execute(
        """
        INSERT INTO paired_devices 
        (device_id, ip_address, shared_secret, role, paired_at)
        VALUES (?, ?, ?, ?, ?)
        """,
        (request.source_device_id, request.source_ip, 
         request.shared_secret, "manager", datetime.utcnow())
    )
    
    # Update own state
    await db.execute(
        "UPDATE device_metadata SET value = ? WHERE key = 'device_state'",
        ("paired",)
    )
    await db.execute(
        "UPDATE device_metadata SET value = ? WHERE key = 'manager_device_id'",
        (request.source_device_id,)
    )
    
    return {
        "status": "accepted",
        "device_id": settings.device_id,
        "serial_number": settings.device_serial,
        "ip_address": get_local_ip()
    }
5. Secure Communication After Pairing
Authentication using Shared Secret:
python# utils/device_auth.py

def create_device_auth_header(shared_secret: str) -> dict:
    """Create authentication header for device-to-device communication"""
    
    timestamp = datetime.utcnow().isoformat()
    message = f"{settings.device_id}:{timestamp}"
    
    # Create HMAC signature
    import hmac
    signature = hmac.new(
        shared_secret.encode(),
        message.encode(),
        hashlib.sha256
    ).hexdigest()
    
    return {
        "X-Device-ID": settings.device_id,
        "X-Timestamp": timestamp,
        "X-Signature": signature
    }


def verify_device_auth(headers: dict, shared_secret: str) -> bool:
    """Verify device authentication"""
    
    device_id = headers.get("X-Device-ID")
    timestamp = headers.get("X-Timestamp")
    signature = headers.get("X-Signature")
    
    if not all([device_id, timestamp, signature]):
        return False
    
    # Check timestamp (prevent replay attacks)
    try:
        request_time = datetime.fromisoformat(timestamp)
        if datetime.utcnow() - request_time > timedelta(minutes=5):
            return False  # Request too old
    except:
        return False
    
    # Verify signature
    message = f"{device_id}:{timestamp}"
    expected_signature = hmac.new(
        shared_secret.encode(),
        message.encode(),
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(signature, expected_signature)


# Middleware for device authentication
@app.middleware("http")
async def device_auth_middleware(request: Request, call_next):
    # Only check device auth for /api/devices/* endpoints
    if request.url.path.startswith("/api/devices/") and \
       request.method in ["POST", "PUT", "DELETE"]:
        
        # Get device ID from headers
        source_device_id = request.headers.get("X-Device-ID")
        
        if source_device_id:
            # Get shared secret from database
            result = await db.fetch_one(
                "SELECT shared_secret FROM paired_devices WHERE device_id = ?",
                (source_device_id,)
            )
            
            if result:
                if not verify_device_auth(request.headers, result["shared_secret"]):
                    return JSONResponse(
                        status_code=401,
                        content={"error": "Invalid device authentication"}
                    )
            else:
                return JSONResponse(
                    status_code=403,
                    content={"error": "Device not paired"}
                )
    
    response = await call_next(request)
    return response
6. Device Communication Client
python# devices/client.py

class DeviceClient:
    """Client for communicating with paired devices"""
    
    def __init__(self, target_device_id: str):
        self.target_device_id = target_device_id
        self.target_ip = None
        self.shared_secret = None
    
    async def initialize(self):
        """Load device info from database"""
        result = await db.fetch_one(
            """
            SELECT ip_address, shared_secret 
            FROM paired_devices 
            WHERE device_id = ?
            """,
            (self.target_device_id,)
        )
        
        if not result:
            raise ValueError(f"Device {self.target_device_id} not paired")
        
        self.target_ip = result["ip_address"]
        self.shared_secret = result["shared_secret"]
    
    async def call_api(self, method: str, endpoint: str, data: dict = None):
        """Make authenticated API call to paired device"""
        
        if not self.shared_secret:
            await self.initialize()
        
        # Create authentication headers
        auth_headers = create_device_auth_header(self.shared_secret)
        
        async with httpx.AsyncClient(verify=False, timeout=30.0) as client:
            response = await client.request(
                method=method,
                url=f"https://{self.target_ip}:8000{endpoint}",
                json=data,
                headers=auth_headers
            )
            
            response.raise_for_status()
            return response.json()
    
    # Convenience methods
    async def start_scan(self, scan_params: dict):
        return await self.call_api("POST", "/api/sensors/scan/start", scan_params)
    
    async def get_status(self):
        return await self.call_api("GET", "/api/sensors/status")
    
    async def shutdown(self):
        return await self.call_api("POST", "/api/system/shutdown")
7. UI Flow for Manual Pairing
python# templates/devices/pair.html (simplified)
"""
1. User enters IP address: 192.168.1.11
2. Click "Discover Device"
3. Show device info if found
4. Click "Pair Device" button
5. Show success message
6. Device appears in device list
"""

# JavaScript for the flow
"""
<script>
async function discoverDevice() {
    const ip = document.getElementById('device-ip').value;
    const response = await fetch('/api/devices/discover/manual', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ip_address: ip})
    });
    
    const result = await response.json();
    if (result.discovered && result.can_pair) {
        document.getElementById('device-info').innerHTML = `
            <p>Found: ${result.device.name}</p>
            <p>Serial: ${result.device.serial_number}</p>
            <button onclick="pairDevice('${ip}')">Pair Device</button>
        `;
    }
}

async function pairDevice(ip) {
    const response = await fetch('/api/devices/pair/initiate', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({target_ip: ip})
    });
    
    if (response.ok) {
        alert('Device paired successfully!');
        window.location.href = '/devices';
    }
}
</script>
"""

Database Schema for Pairing
sql-- Paired devices table
CREATE TABLE paired_devices (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    device_id VARCHAR(64) UNIQUE NOT NULL,
    ip_address VARCHAR(45) NOT NULL,
    shared_secret TEXT NOT NULL,  -- For authentication
    role VARCHAR(16) NOT NULL CHECK (role IN ('manager', 'sensor')),
    paired_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_seen TIMESTAMP
);

-- Pairing tokens (for secure handshake)
CREATE TABLE pairing_tokens (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    token VARCHAR(128) UNIQUE NOT NULL,
    source_device_id VARCHAR(64) NOT NULL,
    target_device_id VARCHAR(64) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NOT NULL,
    used BOOLEAN DEFAULT FALSE
);

-- Device metadata
CREATE TABLE device_metadata (
    key VARCHAR(64) PRIMARY KEY,
    value TEXT
);

-- Initial data
INSERT INTO device_metadata VALUES 
    ('device_id', 'cthz-device-001'),
    ('device_state', 'unconfigured'),
    ('is_manager', 'false'),
    ('manager_device_id', NULL);

Testing the Flow
Step 1: Setup Device 1
bash# Device 1 (192.168.1.10)
curl -X POST https://192.168.1.10:8000/api/auth/setup \
  -H "Content-Type: application/json" \
  -d '{"username": "admin", "password": "SecurePass123!"}'
Step 2: Discover Device 2 from Device 1
bashcurl -X POST https://192.168.1.10:8000/api/devices/discover/manual \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <jwt_token>" \
  -d '{"ip_address": "192.168.1.11"}'
Step 3: Pair Devices
bashcurl -X POST https://192.168.1.10:8000/api/devices/pair/initiate \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <jwt_token>" \
  -d '{"target_ip": "192.168.1.11"}'
Step 4: Verify Pairing
bashcurl https://192.168.1.10:8000/api/devices \
  -H "Authorization: Bearer <jwt_token>"